
# Домашнее задание к занятию "5.3. Введение. Экосистема. Архитектура. Жизненный цикл Docker контейнера"

## Как сдавать задания

Обязательными к выполнению являются задачи без указания звездочки. Их выполнение необходимо для получения зачета и диплома о профессиональной переподготовке.

Задачи со звездочкой (*) являются дополнительными задачами и/или задачами повышенной сложности. Они не являются обязательными к выполнению, но помогут вам глубже понять тему.

Домашнее задание выполните в файле readme.md в github репозитории. В личном кабинете отправьте на проверку ссылку на .md-файл в вашем репозитории.

Любые вопросы по решению задач задавайте в чате учебной группы.

---

## Задача 1

Сценарий выполения задачи:

- создайте свой репозиторий на https://hub.docker.com;
- выберете любой образ, который содержит веб-сервер Nginx;
- создайте свой fork образа;
- реализуйте функциональность:
запуск веб-сервера в фоне с индекс-страницей, содержащей HTML-код ниже:
```
<html>
<head>
Hey, Netology
</head>
<body>
<h1>I’m DevOps Engineer!</h1>
</body>
</html>
```
Опубликуйте созданный форк в своем репозитории и предоставьте ответ в виде ссылки на https://hub.docker.com/username_repo.

```
160420@pk160420 MINGW64 /c/test/docker docker pull romb32/docker101tutorial
160420@pk160420 MINGW64docker run -p 80:80 -dit romb32/docker101tutorial 
160420@pk160420 MINGW64 /c/test/docker docker exec -it b2df54918834 bash
root@b2df54918834 / 
$ cat usr/share/nginx/html/index.html
<html>
<head>:
Hey, Netology
</head>
<body>
<h1>I’m DevOps Engineer!</h1>
</body>
</html>



160420@pk160420 MINGW64 /c/test
$ docker ps
CONTAINER ID   IMAGE                      COMMAND     
             CREATED              STATUS
PORTS                NAMES
0.0.0.0:80->80/tcp   sharp_cannon
b2df54918834   docker101tutorial:latest   "/docker-entrypoint.…"   56 minutes ago       Up 43 minutes       
80/tcp               great_goldwasser



160420@pk160420 MINGW64 /c/test/docker
$ docker push romb32/docker101tutorial:tagname
The push refers to repository [docker.io/romb32/docker101tutorial]
An image does not exist locally with the tag: romb32/docker101tutorial

160420@pk160420 MINGW64 /c/test/docker
$ docker build -t romb32/docker101tutorial .
[+] Building 5.2s (9/9) FINISHED
 => [internal] load build definition from Docke  0.7s 
 => => transferring dockerfile: 32B              0.0s 
 => [internal] load .dockerignore                1.0s 
 => => transferring context: 2B                  0.0s 
 => [internal] load metadata for docker.io/libr  3.2s 
 => [auth] library/alpine:pull token for regist  0.0s 
 => [1/4] FROM docker.io/library/alpine:3.14@sh  0.0s 
 => CACHED [2/4] RUN CARGO_NET_GIT_FETCH_WITH_C  0.0s 
 => CACHED [3/4] RUN mkdir /ansible &&     mkdi  0.0s 
 => CACHED [4/4] WORKDIR /ansible                0.0s 
 => exporting to image                           0.4s 
 => => exporting layers                          0.0s 
 => => writing image sha256:9f73745d9abc15a37b7  0.1s 
 => => naming to docker.io/romb32/docker101tuto  0.1s 

Use 'docker scan' to run Snyk tests against images to 
find vulnerabilities and learn how to fix them        

160420@pk160420 MINGW64 /c/test/docker
$ docker push romb32/docker101tutorial:latest
The push refers to repository [docker.io/romb32/docker101tutorial]
5f70bf18a086: Pushed
2fd6458687e0: Pushed
44ea17e49620: Pushed
1a058d5342cc: Pushed
latest: digest: sha256:0990ce2e6e8d81f4bf8bf441b5f6d8295cf00c008c3a35d79d4874c11b7815ff size: 1153

https://hub.docker.com/repository/docker/romb32/docker101tutorial
```

## Задача 2

Посмотрите на сценарий ниже и ответьте на вопрос:
"Подходит ли в этом сценарии использование Docker контейнеров или лучше подойдет виртуальная машина, физическая машина? Может быть возможны разные варианты?"

Детально опишите и обоснуйте свой выбор.

--

Сценарий:

- Высоконагруженное монолитное java веб-приложение;
- Nodejs веб-приложение;
- Мобильное приложение c версиями для Android и iOS;
- Шина данных на базе Apache Kafka;
- Elasticsearch кластер для реализации логирования продуктивного веб-приложения - три ноды elasticsearch, два logstash и две ноды kibana;
- Мониторинг-стек на базе Prometheus и Grafana;
- MongoDB, как основное хранилище данных для java-приложения;
- Gitlab сервер для реализации CI/CD процессов и приватный (закрытый) Docker Registry.

```
Высоконагруженное монолитное java веб-приложение;
 - физический сервер, т.к. монолитное, селдовательно в микросерверах не реализуемо без изменения кода,
   и так как высоконагруженное -  то необходим физический доступ к ресурсами, без использования гипервизора виртуалки. 

Go-микросервис для генерации отчетов;
 - докер, класический вариант использования контейнеров 
 
Nodejs веб-приложение;
 - это веб приложение, для таких приложений достаточно докера, противопоказаний для контейнерной реализации не вижу.
   и в рамках микропроцессрной архитектуры может быть хорошим решением. 
 
Мобильное приложение c версиями для Android и iOS;
 - Виртаулка -  приложение в докере не имеет GUI, а это по описанию не вариант. 

База данных postgresql используемая, как кэш;
  - в идеале для БД использовать Виртуалку, если доступ к кешу нужен для разных систем, пользователей, 
    использование БД на докере не рекомендуется.
    а так же должен быть сохранен между сессиями , при остановке  приклада.
    вариант с Контейнером(докер) можно рассмотреть только если данные нужны только в рамках сессии 
    самого приложения работающего на этом же контейнере.
    

Шина данных на базе Apache Kafka;
 - зависит от передаваемых данных или контура (тест/прод), для прода и критичности данных лучше Вируалка, для теста достаточно Контейнерной реализации, 
   если потеря данных при потере контенйера не является критичной то можно и в контейнере. 

Очередь для Logstash на базе Redis;
 - физическая машина, так как требуется высокая производительность, т.к. в описании системы в задачах именно производительность заявлена.
   в теории можно и на Аппаратной виртуализации реализовать, зависит от нагрузки, задач и имеющейся инфораструктуры. 
  
Elastic stack для реализации логирования продуктивного веб-приложения - три ноды elasticsearch, два logstash и две ноды kibana;
 - сам Elasticsearvh лучше на виртуалку, отказоустойчивость решается на уровне кластера, 
   кибану и логсташ можно вынести в докер контейнер, или так же на виртуалках.
   существуют решения и в таком и в таком исполнении - в интернете есть описания (ссылки не стал кприкладывать :) )
   использование в Докерем может дать "+" для использования в тестовом периоде с максимальным функционалом, 
   в докере можно перезаливать машину каждый месяц и получать опять полную функциональность

Мониторинг-стек на базе prometheus и grafana;
 - сами системы не хранят как таковых данны, можно развернуть на Докере,
   минусов не вижу, в + скорость развертывания, возможность масштабирования для различных задачь: 
     например у графаны есть ограничение на число обрабатываемых метрик и может понадобиться разделения под разные задачи (контуры)

Mongodb, как основное хранилище данных для java-приложения;
 - можно использовать Виртуальную машину, т.к. хранилище и  не сказано что высоконагруженное
   в Контейнере хранить БД с данными не подходит
   для физического сервера может быть через чур расточительно

Jenkins-сервер.
 - так же класический кейс для контейнерной реализации Докер, данных сам не хранит. 
```
## Задача 3

- Запустите первый контейнер из образа ***centos*** c любым тэгом в фоновом режиме, подключив папку ```/data``` из текущей рабочей директории на хостовой машине в ```/data``` контейнера;
- Запустите второй контейнер из образа ***debian*** в фоновом режиме, подключив папку ```/data``` из текущей рабочей директории на хостовой машине в ```/data``` контейнера;
- Подключитесь к первому контейнеру с помощью ```docker exec``` и создайте текстовый файл любого содержания в ```/data```;
- Добавьте еще один файл в папку ```/data``` на хостовой машине;
- Подключитесь во второй контейнер и отобразите листинг и содержание файлов в ```/data``` контейнера.

```
160420@pk160420 MINGW64 /c/test/docker
$ docker exec -it elastic_bartik /bin/bash
root@de5978dea65b /
# touch /share/info/myfile
root@de5978dea65b /
$ echo 1_centos>/share/info/myfile
root@de5978dea65b /
$ exit
exit

Листинг из терминала для хостовой машины

160420@pk160420 MINGW64 /
$ cd info

160420@pk160420 MINGW64 /info
$  dir
myfile

160420@pk160420 MINGW64 /info 
$ cat myfile
1_centos

160420@pk160420 MINGW64 /info
$ echo my_host_content>hostfile
160420@pk160420 MINGW64 /info 
$ dir
hostfile  myfile
160420@pk160420 MINGW64 /info


Листинг из терминаля для  работы с контенерами :

160420@pk160420 MINGW64 /
$ docker exec -it wonderful_taussig /bin/bash
root@69c46eacb43c /
$ cd info
root@69c46eacb43c /info
$ dir
hostfile  myfile
root@69c46eacb43c /info
$ cat myfile
1_centos
root@69c46eacb43c /info
$ cat hostfile
my_host_content
root@69c46eacb43c /info

```
## Задача 4 (*)

Воспроизвести практическую часть лекции самостоятельно.

Соберите Docker образ с Ansible, загрузите на Docker Hub и пришлите ссылку вместе с остальными ответами к задачам.


---

### Как cдавать задание

Выполненное домашнее задание пришлите ссылкой на .md-файл в вашем репозитории.

---
